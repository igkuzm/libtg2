#include "tg.h"
#include "crypto/cmn.h"
#include "crypto/cry.h"
#include "crypto/hsh.h"
#include "../essential/serialize.h"
#include "../essential/endian.h"
#include <string.h>
#include <stdbool.h>
#include "../libtg.h"
#include "send_query.h"
#include "strerr.h"

#define SWAP(a, b) (((a) ^= (b)), ((b) ^= (a)), ((a) ^= (b)))

bool tg_has_auth_key(tg_t *tg){
	if (tg->key.size)
		return true;
	return false;
} 

int tg_new_auth_key(tg_t *tg)
{
	memset(&tg->key, 0, sizeof(buf_t));

	// get fingerprint
	tg->fingerprint = tg_cry_rsa_fpt(tg->pubkey);

	ON_LOG(tg, "%s: public RSA fingerprint: %.16lx", 
			__func__, tg->fingerprint);
	
 /* Client sends query to server
	* req_pq_multi#be7e8ef1 nonce:int128 = ResPQ;
	* The value of nonce is selected randomly by the client
	* (random number) and identifies the client within this
	* communication. Following this step, it is known to
	* all */

	tl_t *tl = NULL;
	buf_t nonce = buf_rand(16);
	buf_t req_pq = tl_req_pq_multi(nonce);
	tl = tg_send_query_sync(tg, &req_pq, false);
 /* Server sends response of the form
	* resPQ#05162463 nonce:int128 server_nonce:int128
	* pq:string server_public_key_fingerprints:Vector long =
	* ResPQ;
	* Here, string pq is a representation of a natural number
	* (in binary big endian format). This number is the
	* product of two different odd prime numbers. Normally,
	* pq is less than or equal to 2^63-1. The value of
	* server_nonce is selected randomly by the server;
	* following this step, it is known to all.
	*
	* server_public_key_fingerprints is a list of public RSA
	* key fingerprints (64 lower-order bits of SHA1
	* (server_public_key); the public key is represented as a
	* bare type rsa_public_key n:string e:string =
	* RSAPublicKey, where, as usual, n and e are numbers in
	* big endian format serialized as strings of bytes,
	* following
	* which SHA1 is computed) received by the server.
	*
	* All subsequent messages contain the pair (nonce,
	* server_nonce) both in the plain-text, and the encrypted
	* portions which makes it possible to identify a
	* “temporary session” — one run of the key generation
	* protocol described on this page that uses the same
	* (nonce, server_nonce) pair. An intruder could not create
	* a parallel session with the server with the same
	* parameters and reuse parts of server- or
	* client-encrypted messages for its own purposes in such a
	* parallel
	* session, because a different server_nonce would be
	* selected by the server for any new “temporary session”.
	*/
	if (tl && tl->_id == id_resPQ){
		tl_resPQ_t resPQ = *(tl_resPQ_t *)tl;
		// handle fingerprints
		int i, nfpt = -1; // fingerprint number
		for (i = 0; 
				i < resPQ.server_public_key_fingerprints_len;
			 	++i) 
		{
			ON_LOG(tg, "%s: server fingerprint %d: %.16lx", 
					__func__, i, resPQ.server_public_key_fingerprints_[i]);
			if (resPQ.server_public_key_fingerprints_[i] ==
					tg->fingerprint)
				{
					nfpt = i;	
					break;
				}
		}
		if (nfpt == -1){
			ON_ERR(tg, 
					"%s: no server RSA public key matching", __func__);
			return 1;
		}

		uint64_t pq_ = buf_get_ui64(buf_swap(resPQ.pq_));
		ON_LOG(tg, "%s: pq: %ld", __func__, pq_);

	 /* Client decomposes pq into prime factors such that
		* p < q. */
		uint32_t p_, q_;
		tg_cmn_fact(pq_, &p_, &q_);
		if (!(p_ < q_)) {
			SWAP(p_, q_);
		}
		ON_LOG(tg, "%s: p: %d, q: %d", __func__, p_, q_);

		buf_t p  = buf_swap(buf_add_ui32(p_));
		buf_t q  = buf_swap(buf_add_ui32(q_));

	 /* encrypted_data payload generation */
	 /* new_nonce := another (good) random number generated by
		* the client; after this query, it is known to both
		* client and server */
		buf_t new_nonce = buf_rand(32);

	 /* data := a serialization of
		*
		* p_q_inner_data_dc#a9f55f95 pq:string p:string
		* q:string nonce:int128 server_nonce:int128
		* new_nonce:int256 dc:int = P_Q_inner_data;
		*
		* or of
		*
		* p_q_inner_data_temp_dc#56fddf88 pq:string
		* p:string q:string nonce:int128
		* server_nonce:int128 new_nonce:int256
		* dc:int expires_in:int = P_Q_inner_data;
		*
		* where dc is the ID of the DC we're
		* talking to; 10000 has to be added to
		* the DC ID when connecting to the test
		* servers; it has to be made negative if
		* the DC
		* we're connecting to is a media
		* (not CDN) DC.
		*/
		buf_t data = 
			tl_p_q_inner_data_dc(
					&resPQ.pq_, 
					&p, 
					&q, 
					resPQ.nonce_, 
					resPQ.server_nonce_, 
					new_nonce, 
					htole32(tg->dc.number));

		ON_LOG_BUF(tg, data,"%s: p_q_inner_data_dc: ", __func__);

	 /* encrypted_data := RSA_PAD (data, server_public_key),
		* where RSA_PAD is a version of RSA with a variant of
		* OAEP+ padding explained below in 4.1) */
			
	 /* data_with_padding := data + random_padding_bytes; --
		* where random_padding_bytes are chosen so that the
		* resulting length of data_with_padding is precisely
		*     192 bytes, and data is the TL-serialized data to
		*     be encrypted as before. One has to check that
		*     data is not longer than 144 bytes. */
		if (data.size > 144*8){
			ON_ERR(tg,  
					"%s: data len is longer 144 bytes: %d",
				 	__func__, data.size);
			return 1;
		}
		buf_t random_padding_bytes = 
			buf_rand(192*8 - data.size);
		buf_t data_with_padding = 
			buf_add_bufs(2, data, random_padding_bytes);

		/* data_pad_reversed := BYTE_REVERSE(data_with_padding);
		 * -- is obtained from data_with_padding by reversing
		 *  the byte order.*/
		buf_t data_pad_reversed = 
			buf_swap(buf_add_buf(data_with_padding));

		int tryes = 0;
generation_new_random_temp_key:;
		/* a random 32-byte temp_key is generated */
		buf_t temp_key = buf_rand(32*8);

		/* data_with_hash := data_pad_reversed + SHA256(temp_key
		 * + data_with_padding); -- after this assignment,
		 * data_with_hash is exactly 224 bytes long. */
		buf_t temp_key_data_with_padding = 
			buf_add_bufs(2, temp_key, data_with_padding);
		buf_t data_with_hash = 
			buf_add_bufs(2, 
					data_pad_reversed, 
					tg_hsh_sha256(temp_key_data_with_padding));
		if (data_with_hash.size != 224*8){
			ON_ERR(tg, 
					"%s: data_with_hash len is longer 244 bytes: %d",
				 	__func__, data_with_hash.size);
			 return 1;
		 }

		/* aes_encrypted := AES256_IGE(data_with_hash, temp_key,
		 * 0); -- AES256-IGE encryption with zero IV. */
		buf_t aes_encrypted = 
			tg_cry_aes_e(data_with_hash, temp_key, buf_add_ui32(0));

		/* temp_key_xor := temp_key XOR SHA256(aes_encrypted);
		 * -- adjusted key, 32 bytes */
		buf_t aes_encrypted_hash = tg_hsh_sha256(aes_encrypted);
		buf_t temp_key_xor = buf_xor(temp_key, aes_encrypted_hash);
			
		/* key_aes_encrypted := temp_key_xor + aes_encrypted; --
		 * exactly 256 bytes (2048 bits) long */
		buf_t key_aes_encrypted = 
			buf_add_bufs(2, temp_key_xor, aes_encrypted);
		 if (key_aes_encrypted.size != 256*8){
			ON_ERR(tg, 
					"%s: key_aes_encrypted len mismatch: expexted 2048: has: %d",
				 	__func__, key_aes_encrypted.size);
			 return 1;
		 }

		 ON_LOG_BUF(tg, key_aes_encrypted, 
				 "%s: key_aes_encrypted: ", __func__);

		/* The value of key_aes_encrypted is compared with the
		 * RSA-modulus of server_pubkey as a big-endian 2048-bit
		 * (256-byte) unsigned integer. If key_aes_encrypted
		 * turns out to be greater than or equal to the RSA
		 * modulus, the previous steps starting from the
		 * generation of new random temp_key are repeated.
		 * Otherwise the final step is performed: */
		 if (tg_cry_rsa_cmp(tg->pubkey, key_aes_encrypted) >= 0)
		 {
			ON_LOG(tg, 
					"%s: key_aes_encrypted is greater than or "
					"equal to the RSA-modulus of server_pubkey. "
					"generate new temp_key", __func__);
			if (tryes++ > 100){
				ON_ERR(tg, NULL, "%s: can't generate temp_key", __func__);
				return 1;
			}
			 
			goto generation_new_random_temp_key;
		 }

		/* encrypted_data := RSA(key_aes_encrypted,
		 * server_pubkey); -- 256-byte big-endian integer is
		 * elevated to the requisite power from the RSA public
		 * key modulo the RSA modulus, and the result is 
		 * stored as a big-endian integer consisting of 
		 * exactly 256 bytes (with leading zero bytes if 
		 * required). */
		 buf_t encrypted_data = 
			 tg_cry_rsa_enc(tg->pubkey, key_aes_encrypted);
		 ON_LOG_BUF(tg, encrypted_data, 
				 "%s: encrypted_data: ", __func__);
		 
		 /*int pad = 2048 - encrypted_data.size;*/
		 /*buf_t encrypted_data; */
		 /*buf_init(&encrypted_data);*/
		 /*buf_realloc(&encrypted_data, 2048);*/
		 /*encrypted_data.size = pad;*/
		 /*memset(encrypted_data.data, 0, pad);*/
		 /*encrypted_data = */
			 /*buf_cat(encrypted_data, encrypted_data_);*/
		 /*buf_free(encrypted_data_);*/
		 /*if (encrypted_data.size != 256*8){*/
			/*ON_ERR(tg, NULL, */
					/*"%s: encrypted_data len mismatch: expexted 2048, has: %d",*/
					 /*__func__, encrypted_data.size);*/
			 /*return 1;*/
		 /*}*/

		/* Send req_DH_params query with generated
		 * encrypted_data */
		buf_t req_DH_params = 
			tl_req_DH_params(
					resPQ.nonce_,
					 resPQ.server_nonce_, 
					&p, &q, 
					resPQ.server_public_key_fingerprints_[nfpt], 
					&encrypted_data);

		 ON_LOG_BUF(tg, req_DH_params, 
				 "%s: req_DH_params: ", __func__);

		tl = tg_send_query_sync(tg, &req_DH_params, false);
	 /* Server responds with
		* server_DH_params_ok#d0e8075c nonce:int128
		* server_nonce:int128 encrypted_answer:string =
		* Server_DH_Params
		* If the query is incorrect, the server returns a -404
		* error and the handshake must be restarted (any
		* subsequent request also returns -404, even if it is
		* correct).
		* A -444 error may also be returned if a test DC
		* ID is passed in p_q_inner_data_(_temp)dc when
		* handshaking with a production DC, and vice
		* versa. */

		if (tl && tl->_id == id_server_DH_params_ok){
			printf("DONE!\n");

		}
	}

	// throw error
	char *err = tg_strerr(tl); 
	ON_ERR(tg, "%s", err);
	free(err);

	return 1;
}

/*
int tg_new_auth_key2(tg_t *tg)
{
	memset(&tg->key, 0, sizeof(buf_t));

	// get fingerprint
	tg->fingerprint = tg_cry_rsa_fpt(tg);

	ON_LOG(tg, "%s: public RSA fingerprint: %.16lx", 
			__func__, tg->fingerprint);
	
	tl_t *tl = NULL;
	buf_t nonce = buf_rand(16);
	buf_t req_pq = 
		buf_add_bufs(2, buf_add_ui32(0x60469778), nonce);

	tl = tg_send_query_(tg, req_pq, false);

	if (tl && tl->_id == id_resPQ){
		tl_resPQ_t resPQ = *(tl_resPQ_t *)tl;
	
		// handle fingerprints
		int i, nfpt = -1; // fingerprint number
		for (i = 0; 
				i < resPQ.server_public_key_fingerprints_len;
			 	++i) 
		{
			ON_LOG(tg, "%s: server fingerprint %d: %.16lx", 
					__func__, i, resPQ.server_public_key_fingerprints_[i]);
			if (resPQ.server_public_key_fingerprints_[i] ==
					tg->fingerprint)
				{
					nfpt = i;	
					break;
				}
		}
		if (nfpt == -1){
			ON_ERR(tg, 
					"%s: no server RSA public key matching", __func__);
			return 1;
		}
		buf_t fingerprint = 
			buf_add_ui64(resPQ.server_public_key_fingerprints_[nfpt]);

		uint64_t pq = buf_get_ui64(buf_swap(resPQ.pq_));
		ON_LOG(tg, "%s: pq: %ld", __func__, pq);

	 ///Client decomposes pq into prime factors such that
		// p < q.
		uint32_t p_, q_;
		tg_cmn_fact(pq, &p_, &q_);
		if (!(p_ < q_)) {
			SWAP(p_, q_);
		}
		ON_LOG(tg, "%s: p: %d, q: %d", __func__, p_, q_);

		buf_t p  = buf_swap(buf_add_ui32(p_));
		buf_t q  = buf_swap(buf_add_ui32(q_));

		buf_t new_nonce = buf_rand(32);
		new_nonce.size = 32;

		// inner data
		buf_t p_q_inner_data = 
			buf_add_bufs(7,
					buf_add_ui32(0x83c95aec),
					serialize_str(resPQ.pq_),
					serialize_str(p),
					serialize_str(q),
					nonce,
					resPQ.server_nonce_,
					new_nonce);
		ON_LOG_BUF(tg, p_q_inner_data, "%s: p_q_inner_data: ", __func__);
		
		// hash
		buf_t h = tg_hsh_sha1(p_q_inner_data);

		buf_t dwh = buf_add_bufs(2, h, p_q_inner_data);
		//buf_t pad = buf_rand(256);
		buf_t pad = buf_new();
		pad.size = 255 - dwh.size;
		dwh = buf_cat(dwh, pad);
		ON_LOG_BUF(tg, dwh, "%s: dwh: ", __func__);
		
		buf_t encrypted_data = tg_cry_rsa_e(tg, dwh); 
		ON_LOG_BUF(tg, encrypted_data, "%s: encrypted_data: ", __func__);

		// req_DH_params
		buf_t req_DH_params = 
			buf_add_bufs(7,
					buf_add_ui32(0xd712e4be),
					nonce,
					resPQ.server_nonce_,
					serialize_str(p),
					serialize_str(q),
					fingerprint,
					serialize_str(encrypted_data));
		//ON_LOG_BUF(tg, req_DH_params, "%s: req_DH_params: ", __func__);

		tl = tg_send_query_(tg, req_DH_params, false);
	}
	
	// throw error
	char *err = tg_strerr(tl); 
	ON_ERR(tg, "%s", err);
	free(err);

	return 1;
}
*/
